# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Frontend Communication

MCP server `frontend` connects to frontend Claude Code. **Delegate tasks** via `mcp__frontend__claude_code` tool.

---

## Architecture Overview

### Core Application Purpose

Django-based job/project management system for custom metal fabrication business (Morris Sheetmetal). Digitizes a 50+ year paper-based workflow from quote generation to job completion and invoicing.

### Django Apps Architecture

- **`workflow`** - Central hub, Xero integration, auth middleware
- **`job`** - Job lifecycle, Kanban status tracking (Quoting → In Progress → Completed → Archived), audit trails
- **`accounts`** - Custom Staff model extending AbstractBaseUser, authentication
- **`client`** - Customer management, bidirectional Xero contact sync
- **`timesheet`** - Time tracking, billable/non-billable, wage rates
- **`purchasing`** - POs, stock management, Xero integration, links to CostLine via ext_refs
- **`accounting`** - KPIs, financial reporting, invoice generation
- **`quoting`** - Quote generation, supplier pricing, AI price extraction (Gemini)

### Database Design Patterns

**Core Relationships:**

```
Job → CostSet (1:many) → CostLine (1:many)
PurchaseOrder → PurchaseOrderLine → Stock → CostLine
Staff → CostLine (time entries)
Client → Job (1:many)
```

**Key Design Patterns:**

- UUID primary keys throughout for security
- SimpleHistory for audit trails on critical models
- Soft deletes where appropriate
- JSON ext_refs for flexible external references (stock, purchase orders)
- JSON meta for entry-specific data (structure varies by CostLine kind - see below)
- Bidirectional Xero synchronization with conflict resolution
- `accounting_date` field on CostLine for proper KPI reporting

**CostLine Meta Field Structure:**

TIME entries (kind='time'):
- staff_id (str, UUID): Reference to Staff member
- date (str, ISO): Date work performed (legacy - use accounting_date field instead)
- is_billable (bool): Whether billable to client
- wage_rate_multiplier/rate_multiplier (float): Rate multiplier (e.g., 1.5 for overtime)
- note (str): Optional notes
- created_from_timesheet (bool): True if from modern timesheet UI
- wage_rate, charge_out_rate (float): Rates at time of entry

MATERIAL entries (kind='material'):
- item_code (str): Stock item code reference
- comments (str): Notes about material usage
- source (str): Origin ('delivery_receipt' for PO deliveries)
- retail_rate (float): Retail markup rate (e.g., 0.2 for 20%)
- po_number (str): Purchase order reference
- consumed_by (str): What consumed this material

ADJUSTMENT entries (kind='adjust'):
- comments (str): Explanation of adjustment
- source (str): Origin ('manual_adjustment' for user-created)

## Development Workflow

### Code Style and Quality

- **Black** (line length 88) and **isort** for Python formatting
- **MyPy** with strict configuration for type safety
- **Flake8** and **Pylint** for linting with Django-specific rules
- **NEVER run `tox -e format`** - use pre-commit instead (different settings, different results)
- **NEVER edit **init**.py files directly** - they are autogenerated. Run `python scripts/update_init.py` to regenerate them after adding/removing Python files

### Defensive Programming Philosophy - CRITICAL TO FOLLOW

**FAIL EARLY, HANDLE UNHAPPY CASES FIRST, NO FALLBACKS**

- Check `if <bad_case>: handle_error()` first, never `if <good_case>:` patterns
- Validate required input data upfront - crash if missing
- No default values or fallbacks that mask configuration/data problems
- Trust the data model - don't work around broken data with exception handling

**MANDATORY ERROR PERSISTENCE**
Every exception handler must call `persist_app_error(exc)` - errors stored permanently in database, never lost to log rotation.

```python
from apps.workflow.services.error_persistence import persist_app_error

try:
    operation()
except Exception as exc:
    persist_app_error(exc)  # MANDATORY
    raise  # Fail fast unless business logic allows continuation
```

## Environment Configuration

See `.env.example` for required environment variables. Key integrations: Xero API, Dropbox, MariaDB.

## Migration Management

- Keep migrations small and reviewable; include forward and (where feasible) reverse logic.
- Prefer schema changes over code workarounds that mask data shape issues.

## Critical Architecture Guidelines

### Frontend/Backend Separation

**Rule**: If it doesn't involve the database, business rules, or external systems, it belongs in the frontend. If it involves data integrity, calculations, or persistence, it belongs in the backend.

**Forbidden:**
- Backend serializers for static UI constants (dropdown choices, labels)
- Backend views that return HTML or UI-specific structures
- Frontend making business logic decisions or calculations
- Frontend bypassing backend validation

### Service Layer Patterns

- Keep business logic in explicit service classes; keep views thin.
